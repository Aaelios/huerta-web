CREATE OR REPLACE FUNCTION app.f_is_uuid_v4_v1(p text)
 RETURNS boolean
 LANGUAGE sql
 IMMUTABLE
 SET search_path TO 'pg_catalog', 'public', 'app'
AS $function$
  select p ~* '^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$'
$function$;

CREATE OR REPLACE FUNCTION app.f_sizeof_json_v1(p jsonb)
RETURNS integer
LANGUAGE sql
IMMUTABLE
SET search_path TO 'pg_catalog', 'public', 'app'
AS $function$
  SELECT pg_column_size(p)
$function$;

CREATE OR REPLACE FUNCTION app.f_sha256_json_v1(p jsonb)
 RETURNS text
 LANGUAGE sql
 IMMUTABLE
 SET search_path TO 'pg_catalog', 'public', 'app'
AS $function$
  -- md5(text) retorna hex de 32 chars; suficiente para claves de dedupe
  select md5(coalesce(p, '{}'::jsonb)::text)
$function$

CREATE OR REPLACE FUNCTION app.f_input_redact_v1(p_input jsonb)
 RETURNS jsonb
 LANGUAGE plpgsql
 SET search_path TO 'pg_catalog', 'public', 'app'
AS $function$
declare
  keys_sensitive constant text[] := array[
    'turnstile_token','authorization','cookie','cookies',
    'password','secret','api_key','token','access_token','refresh_token'
  ];
  k text;
  result jsonb := coalesce(p_input, '{}'::jsonb);
  hdr jsonb;
  hdr_key text;
  new_headers jsonb := '{}'::jsonb;
begin
  -- Remover en raíz
  foreach k in array keys_sensitive loop
    if result ? k then
      result := result - k;
    end if;
  end loop;

  -- Filtrar dentro de headers si existe
  if (result ? 'headers') and jsonb_typeof(result->'headers') = 'object' then
    hdr := result->'headers';
    for hdr_key in select key from jsonb_object_keys(hdr) as t(key)
    loop
      if not (hdr_key = any(keys_sensitive)) then
        new_headers := new_headers |jsonb_build_object(hdr_key, hdr->hdr_key);
      end if;
    end loop;
    result := jsonb_set(result, '{headers}', new_headers, true);
  end if;

  return result;
end;
$function$

CREATE OR REPLACE FUNCTION app.f_json_merge_shallow_v1(base jsonb, patch jsonb)
 RETURNS jsonb
 LANGUAGE plpgsql
 SET search_path TO 'pg_catalog', 'public', 'app'
AS $function$
declare
  k text;
  filtered_patch jsonb := '{}'::jsonb;
begin
  if patch is null or patch = 'null'::jsonb then
    return coalesce(base, '{}'::jsonb);
  end if;

  if base is null or base = 'null'::jsonb then
    return coalesce(patch, '{}'::jsonb);
  end if;

  -- Construir patch filtrado: solo claves que NO existen en base
  for k in select key from jsonb_object_keys(patch) as t(key)
  loop
    if not (base ? k) then
      filtered_patch := filtered_patch |jsonb_build_object(k, patch->k);
    end if;
  end loop;

  return base |filtered_patch;
end;
$function$

CREATE OR REPLACE FUNCTION app.f_event_idempotency_key_v1(p_email citext, p_campaign_id text, p_event_type text, p_request_id uuid)
RETURNS text
LANGUAGE sql
IMMUTABLE
SET search_path TO 'pg_catalog', 'public', 'app'
AS $function$
  SELECT
    lower(coalesce(p_email::text,'')) || ':' ||
    coalesce(nullif(p_campaign_id,''), coalesce(p_request_id::text,'')) || ':' ||
    lower(coalesce(p_event_type,''))
$function$;

CREATE OR REPLACE FUNCTION app.f_contact_normalize_v1(p_input jsonb)
 RETURNS jsonb
 LANGUAGE plpgsql
 SET search_path TO 'pg_catalog', 'public', 'app'
AS $function$
declare
  v jsonb := coalesce(p_input, '{}'::jsonb);
  email text; type_ text; source_raw text; source_ text;
begin
  email      := lower(trim(coalesce(v->>'email','')));
  type_      := lower(trim(coalesce(v->>'type','')));
  source_raw := lower(trim(coalesce(v->>'source','')));

  source_ := case
               when source_raw in ('web_form_contact','web_form_footer') then 'web_form'
               when source_raw in ('web_form','checkout','import','api') then source_raw
               else source_raw
             end;

  v := jsonb_set(v, '{email}',  to_jsonb(email::text),  true);
  v := jsonb_set(v, '{type}',   to_jsonb(type_::text),  true);
  v := jsonb_set(v, '{source}', to_jsonb(source_::text),true);

  return v;
end;
$function$

CREATE OR REPLACE FUNCTION app.f_contact_validate_v1(p_input jsonb)
 RETURNS void
 LANGUAGE plpgsql
 SET search_path TO 'pg_catalog', 'public', 'app'
AS $function$
declare
  v_email text := lower(trim(coalesce(p_input->>'email','')));
  v_type text := lower(trim(coalesce(p_input->>'type','')));
  v_source text := lower(trim(coalesce(p_input->>'source','')));
  v_request_id text := trim(coalesce(p_input->>'request_id',''));

  allowed_types text[] := array['newsletter','contact_form','support','complaint','suggestion','checkout'];
  allowed_sources text[] := array['web_form','checkout','import','api'];
  allowed_motivos text[] := array['pago','acceso','mejora','consulta','soporte'];

  max_json_bytes constant int := 65536;
  j_utm jsonb := p_input->'utm';
  j_tech jsonb := p_input->'tech_metrics';
  j_context jsonb := p_input->'context';
  j_payload jsonb := p_input->'payload';
  j_metadata jsonb := p_input->'metadata';

  v_motivo text := lower(trim(coalesce(j_metadata->>'motivo','')));
  v_telefono text := trim(coalesce(j_metadata->>'telefono',''));
begin
  -- campos base
  if v_email = '' then raise exception 'invalid_input: email requerido' using errcode='22023'; end if;
  if v_type = '' then raise exception 'invalid_input: type requerido' using errcode='22023'; end if;
  if v_source = '' then raise exception 'invalid_input: source requerido' using errcode='22023'; end if;
  if v_request_id = '' then raise exception 'invalid_input: request_id requerido' using errcode='22023'; end if;

  if v_email !~* '^[A-Z0-9._%+\-]+@[A-Z0-9.\-]+\.[A-Z]{2,}$' then
    raise exception 'invalid_input: email inválido' using errcode='22023';
  end if;
  if not app.f_is_uuid_v4_v1(v_request_id) then
    raise exception 'invalid_input: request_id no es UUID v4' using errcode='22023';
  end if;

  if not (v_type = any(allowed_types)) then
    raise exception 'invalid_input: type no permitido (%)', v_type using errcode='22023';
  end if;
  if not (v_source = any(allowed_sources)) then
    raise exception 'invalid_input: source no permitido (%)', v_source using errcode='22023';
  end if;

  -- tamaños json
  if j_utm      is not null and app.f_sizeof_json_v1(j_utm)      > max_json_bytes then raise exception 'invalid_input: utm excede % bytes', max_json_bytes using errcode='22023'; end if;
  if j_tech     is not null and app.f_sizeof_json_v1(j_tech)     > max_json_bytes then raise exception 'invalid_input: tech_metrics excede % bytes', max_json_bytes using errcode='22023'; end if;
  if j_context  is not null and app.f_sizeof_json_v1(j_context)  > max_json_bytes then raise exception 'invalid_input: context excede % bytes', max_json_bytes using errcode='22023'; end if;
  if j_payload  is not null and app.f_sizeof_json_v1(j_payload)  > max_json_bytes then raise exception 'invalid_input: payload excede % bytes', max_json_bytes using errcode='22023'; end if;
  if j_metadata is not null and app.f_sizeof_json_v1(j_metadata) > max_json_bytes then raise exception 'invalid_input: metadata excede % bytes', max_json_bytes using errcode='22023'; end if;

  -- reglas tipo contact_form / support
  if v_type = 'contact_form' then
    if coalesce(nullif(trim(coalesce(p_input#>>'{payload,message}','')),''),'') = '' then
      raise exception 'invalid_input: payload.message requerido para contact_form' using errcode='22023';
    end if;
  elsif v_type = 'support' then
    if coalesce(nullif(trim(coalesce(p_input#>>'{payload,message}','')),''),'') = '' and
       coalesce(nullif(trim(coalesce(p_input#>>'{payload,topic}','')),''),'') = '' then
      raise exception 'invalid_input: payload.topic o payload.message requerido para support' using errcode='22023';
    end if;
  end if;

  -- validaciones metadata
  if v_motivo <> '' and not (v_motivo = any(allowed_motivos)) then
    raise exception 'invalid_input: metadata.motivo no permitido (%)', v_motivo using errcode='22023';
  end if;

  if v_telefono <> '' and v_telefono !~ '^[0-9+ \-]{7,20}$' then
    raise exception 'invalid_input: metadata.telefono inválido' using errcode='22023';
  end if;
end;
$function$

CREATE OR REPLACE FUNCTION app.f_contacts_apply_consent_v1(p_contact_id uuid, p jsonb)
 RETURNS void
 LANGUAGE plpgsql
 SET search_path TO 'pg_catalog', 'public', 'app'
AS $function$
declare
  v_opt_in boolean := case when (p ? 'marketing_opt_in') then (p->>'marketing_opt_in')::boolean else null end;
  v_opt_in_at timestamptz := (p->>'marketing_opt_in_at')::timestamptz;
  v_source_raw text := lower(trim(coalesce(p->>'consent_source', p->>'source', null)));
  v_source text;
begin
  if p_contact_id is null then
    raise exception 'db_error: contact_id nulo en f_contacts_apply_consent_v1';
  end if;

  -- Mapeo a catálogo reducido:
  -- web_form_contact|web_form_footer -> 'web_form'
  -- checkout|import|api -> se mantienen
  -- cualquier otro -> NULL (no se escribe)
  v_source := case
                when v_source_raw in ('web_form_contact','web_form_footer') then 'web_form'
                when v_source_raw in ('checkout','import','api') then v_source_raw
                else null
              end;

  if v_opt_in is true then
    update public.contacts
       set consent_status = case
                              when coalesce(consent_status,'none') in ('none','unsubscribed') then 'single_opt_in'
                              else consent_status
                            end,
           consent_at     = coalesce(consent_at, coalesce(v_opt_in_at, now())),
           consent_source = coalesce(v_source, consent_source),
           updated_at     = now()
     where id = p_contact_id;
  end if;
end;
$function$

CREATE OR REPLACE FUNCTION app.f_contacts_upsert_v1(p jsonb)
 RETURNS uuid
 LANGUAGE plpgsql
 SET search_path TO 'pg_catalog', 'public', 'app'
AS $function$
declare
  v_email citext := lower(trim(coalesce(p->>'email','')))::citext;
  v_full_name text := nullif(trim(coalesce(p->>'full_name', p->>'name', '')), '');
  v_id uuid;
  v_utm jsonb        := p->'utm';
  v_tech jsonb       := p->'tech_metrics';
  v_metadata jsonb   := p->'metadata';
  v_source text      := lower(trim(coalesce(p->>'source','')));
begin
  if v_email is null or v_email = ''::citext then
    raise exception 'invalid_input: email requerido en f_contacts_upsert_v1';
  end if;

  select id into v_id
  from public.contacts
  where email = v_email
  for update;

  if not found then
    insert into public.contacts (
      email, full_name, status, consent_status, consent_source,
      utm, tech_metrics, metadata, created_at, updated_at
    ) values (
      v_email, v_full_name, 'active', 'none', null,
      coalesce(v_utm, '{}'::jsonb),
      coalesce(v_tech, '{}'::jsonb),
      coalesce(v_metadata, '{}'::jsonb),
      now(), now()
    )
    returning id into v_id;
  else
    update public.contacts c
       set full_name    = coalesce(c.full_name, v_full_name),
           utm          = app.f_json_merge_shallow_v1(c.utm,        v_utm),
           tech_metrics = app.f_json_merge_shallow_v1(c.tech_metrics,v_tech),
           metadata     = app.f_json_merge_shallow_v1(c.metadata,   v_metadata),
           updated_at   = now()
     where c.id = v_id;
  end if;

  perform app.f_contacts_apply_consent_v1(v_id, p);

  update public.contacts
     set consent_source = coalesce(nullif(consent_source,''), nullif(v_source,''))
   where id = v_id;

  return v_id;
end;
$function$

CREATE OR REPLACE FUNCTION app.f_messages_idempotent_v1(p_contact_id uuid, p jsonb)
 RETURNS uuid
 LANGUAGE plpgsql
 SET search_path TO 'pg_catalog', 'public', 'app'
AS $function$
declare
  v_request_id text := p->>'request_id';
  v_source text     := lower(coalesce(p->>'source','web_form'));
  v_payload jsonb   := coalesce(p->'payload','{}'::jsonb);
  v_utm jsonb       := coalesce(p->'utm','{}'::jsonb);
  v_context jsonb   := coalesce(p->'context','{}'::jsonb);
  v_meta_in jsonb   := coalesce(p->'metadata','{}'::jsonb);

  v_input_redacted jsonb := app.f_input_redact_v1(p);
  v_original_hash  text  := app.f_sha256_json_v1(p);
  v_size_bytes     int   := app.f_sizeof_json_v1(p);

  v_metadata jsonb;
  v_id uuid;
begin
  if p_contact_id is null then
    raise exception 'invalid_input: contact_id requerido en f_messages_idempotent_v1';
  end if;
  if v_request_id is null or v_request_id = '' then
    raise exception 'invalid_input: request_id requerido en f_messages_idempotent_v1';
  end if;

  -- Dedupe por (contact_id, metadata->>request_id)
  select id into v_id
  from public.messages
  where contact_id = p_contact_id
    and metadata->>'request_id' = v_request_id
  for update;

  if found then
    return v_id;
  end if;

  -- Metadata final con auditoría
  v_metadata :=
    jsonb_build_object(
      'request_id',     v_request_id,
      'original_hash',  v_original_hash,
      'size_bytes',     v_size_bytes,
      'original_input', v_input_redacted
    ) |v_meta_in;

  -- Insert alineado a columnas reales
  insert into public.messages(
    contact_id, source, payload, utm, context, processing_status, metadata, created_at, updated_at
  ) values (
    p_contact_id, v_source, v_payload, v_utm, v_context, 'received', v_metadata, now(), now()
  )
  returning id into v_id;

  return v_id;
end;
$function$

CREATE OR REPLACE FUNCTION app.f_subscription_events_log_v1(p_contact_id uuid, p jsonb)
 RETURNS uuid
 LANGUAGE plpgsql
 SET search_path TO 'pg_catalog', 'public', 'app'
AS $function$
declare
  v_email citext;
  v_event_type text := lower(trim(coalesce(p->>'event_type','')));
  v_source_raw text := lower(trim(coalesce(p->>'source','')));
  v_source text;
  v_reason text := nullif(trim(coalesce(p->>'reason','')), '');
  v_campaign_id text := nullif(trim(coalesce(p->>'campaign_id','')), '');
  v_request_id uuid := nullif(p->>'request_id','')::uuid;
  v_meta jsonb := coalesce(p->'metadata','{}'::jsonb);
  v_occurred_at timestamptz := coalesce((p->>'occurred_at')::timestamptz, now());
  v_idem text;
  v_id uuid;
begin
  if p_contact_id is null then
    raise exception 'invalid_input: contact_id requerido';
  end if;

  select email into v_email
  from public.contacts
  where id = p_contact_id;

  if v_email is null then
    raise exception 'invalid_input: contact_id inexistente';
  end if;

  -- normalizar source al catálogo de la tabla
  v_source := case
                when v_source_raw in ('web_form','checkout','import','api','provider_webhook') then v_source_raw
                when v_source_raw in ('web_form_contact','web_form_footer') then 'web_form'
                else 'api'
              end;

  -- validar event_type permitido
  if v_event_type not in ('opt_in','double_opt_in','unsubscribe','bounce','complaint') then
    raise exception 'invalid_input: event_type no permitido (%)', v_event_type;
  end if;

  -- clave de idempotencia
  v_idem := app.f_event_idempotency_key_v1(v_email, v_campaign_id, v_event_type, v_request_id);

  -- dedupe por idempotency_key
  select id into v_id
  from public.subscription_events
  where idempotency_key = v_idem
  for update;

  if found then
    return v_id;
  end if;

  -- insert append-only
  insert into public.subscription_events(
    contact_id, event_type, source, reason, campaign_id,
    idempotency_key, metadata, occurred_at, created_at
  ) values (
    p_contact_id, v_event_type, v_source, v_reason, v_campaign_id,
    v_idem, v_meta, v_occurred_at, now()
  )
  returning id into v_id;

  return v_id;
end;
$function$

CREATE OR REPLACE FUNCTION public.current_user_id()
 RETURNS uuid
 LANGUAGE sql
 STABLE
 SET search_path TO 'public'
AS $function$
  select auth.uid()
$function$

CREATE OR REPLACE FUNCTION public.f_auth_get_user(p_email text)
 RETURNS uuid
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public', 'auth'
AS $function$
DECLARE
  v_user_id uuid;
BEGIN
  -- Validación básica
  IF coalesce(trim(p_email), '') = '' THEN
    RAISE EXCEPTION 'INVALID_EMAIL';
  END IF;

  -- Normalizar email
  p_email := lower(p_email);

  -- Buscar en auth.users
  SELECT u.id
    INTO v_user_id
  FROM auth.users u
  WHERE u.email = p_email
  LIMIT 1;

  -- Si no existe, devolver NULL (sin excepción)
  RETURN v_user_id;
END;
$function$

CREATE OR REPLACE FUNCTION public.f_audit_set_updated_at()
 RETURNS trigger
 LANGUAGE plpgsql
 SET search_path TO 'pg_catalog', 'public'
AS $function$
begin new.updated_at := now(); return new; end; $function$

CREATE OR REPLACE FUNCTION public.f_audit_updated_at_only_update()
 RETURNS trigger
 LANGUAGE plpgsql
 SET search_path TO 'pg_catalog', 'public'
AS $function$
begin
  if tg_op = 'UPDATE' then
    new.updated_at := now();
  end if;
  return new;
end;
$function$

CREATE OR REPLACE FUNCTION app.f_audit_updated_at_only_update_v1()
 RETURNS trigger
 LANGUAGE plpgsql
 SET search_path TO 'pg_catalog', 'public', 'app'
AS $function$
begin
  NEW.updated_at := now();
  return NEW;
end;
$function$

CREATE OR REPLACE FUNCTION public.tg_set_updated_at()
 RETURNS trigger
 LANGUAGE plpgsql
 SET search_path TO 'public', 'pg_temp'
AS $function$
begin
  new.updated_at := now();
  return new;
end$function$

CREATE OR REPLACE FUNCTION public.f_block_update_delete()
 RETURNS trigger
 LANGUAGE plpgsql
 SET search_path TO 'pg_catalog', 'public'
AS $function$
begin
  raise exception 'Append-only table: % not allowed on %', tg_op, tg_table_name;
end;
$function$

CREATE OR REPLACE FUNCTION public.f_bundles_expand_items(p_bundle_sku text)
 RETURNS TABLE(sku text, fulfillment_type text)
 LANGUAGE plpgsql
 STRICT SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
declare
  v_ft    text;
  v_count int;
begin
  if coalesce(trim(p_bundle_sku), '') = '' then
    raise exception 'INVALID_BUNDLE_SKU';
  end if;

  -- Verifica que el SKU exista y sea bundle
  select lower(p.fulfillment_type)
    into v_ft
  from public.products p
  where p.sku = p_bundle_sku;

  if v_ft is null then
    raise exception 'BUNDLE_NOT_FOUND';
  end if;

  if v_ft <> 'bundle' then
    raise exception 'NOT_A_BUNDLE';
  end if;

  -- Debe tener hijos
  select count(*) into v_count
  from public.bundle_items bi
  where bi.bundle_sku = p_bundle_sku;

  if v_count = 0 then
    raise exception 'BUNDLE_EMPTY';
  end if;

  -- Retorna hijos válidos (no soporta bundles anidados)
  return query
  select p.sku, lower(p.fulfillment_type) as fulfillment_type
  from public.bundle_items bi
  join public.products p on p.sku = bi.child_sku
  where bi.bundle_sku = p_bundle_sku
    and lower(p.status) in ('active','sunsetting')
    and lower(p.fulfillment_type) in ('course','template','live_class','one_to_one','subscription_grant');
end;
$function$

CREATE OR REPLACE FUNCTION public.f_catalog_price_by_sku(p_sku text, p_currency text DEFAULT NULL::text)
 RETURNS TABLE(stripe_price_id text, amount_cents integer, currency text, metadata jsonb)
 LANGUAGE plpgsql
 STABLE PARALLEL SAFE SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
DECLARE
  has_any_sku   boolean;
  has_curr_sku  boolean;
  best_level    text;
  r1 RECORD;
  r2 RECORD;
BEGIN
  -- 0) Validación básica de existencia por SKU en precios vigentes
  SELECT EXISTS (
    SELECT 1 FROM public.v_prices_vigente v
    WHERE v.sku = p_sku
  ) INTO has_any_sku;

  IF NOT has_any_sku THEN
    RAISE EXCEPTION 'NOT_FOUND: no hay precios vigentes para sku %', p_sku
      USING ERRCODE = 'P0002';
  END IF;

  -- 1) Si se pasa moneda, validar que exista al menos un precio vigente en esa moneda
  IF p_currency IS NOT NULL THEN
    SELECT EXISTS (
      SELECT 1 FROM public.v_prices_vigente v
      WHERE v.sku = p_sku AND v.currency = p_currency
    ) INTO has_curr_sku;

    IF NOT has_curr_sku THEN
      RAISE EXCEPTION 'INVALID_CURRENCY: no hay precio vigente para sku % en moneda %', p_sku, p_currency
        USING ERRCODE = '22023';
    END IF;
  END IF;

  -- 2) Determinar el nivel ganador por prioridad (launch > default)
  SELECT v.price_list
  INTO best_level
  FROM public.v_prices_vigente v
  WHERE v.sku = p_sku
    AND (p_currency IS NULL OR v.currency = p_currency)
    AND v.price_list IN ('launch','default')
  ORDER BY CASE v.price_list WHEN 'launch' THEN 1 WHEN 'default' THEN 2 ELSE 99 END
  LIMIT 1;

  IF best_level IS NULL THEN
    RAISE EXCEPTION 'NOT_FOUND: no hay precios elegibles por prioridad para sku %', p_sku
      USING ERRCODE = 'P0002';
  END IF;

  -- 3) Dentro del nivel ganador, ordenar por recencia y tomar Top 2 para detectar empate "real"
  WITH ranked AS (
    SELECT
      v.stripe_price_id,
      v.amount_cents,
      v.currency,
      v.metadata,
      v.valid_from,
      v.created_at,
      row_number() OVER (
        ORDER BY v.valid_from DESC NULLS LAST, v.created_at DESC
      ) AS rn
    FROM public.v_prices_vigente v
    WHERE v.sku = p_sku
      AND (p_currency IS NULL OR v.currency = p_currency)
      AND v.price_list = best_level
  )
  SELECT r.stripe_price_id, r.amount_cents, r.currency, r.metadata, r.valid_from, r.created_at
  INTO r1
  FROM ranked r
  WHERE r.rn = 1;

  -- Si no hay ganador dentro del nivel → NOT_FOUND
  IF r1 IS NULL THEN
    RAISE EXCEPTION 'NOT_FOUND: no hay precios vigentes dentro del nivel % para sku %', best_level, p_sku
      USING ERRCODE = 'P0002';
  END IF;

  -- Cargar el segundo candidato, si existe
  SELECT r.valid_from, r.created_at
  INTO r2
  FROM (
    SELECT valid_from, created_at, rn
    FROM (
      SELECT valid_from, created_at,
             row_number() OVER (ORDER BY valid_from DESC NULLS LAST, created_at DESC) AS rn
      FROM public.v_prices_vigente v
      WHERE v.sku = p_sku
        AND (p_currency IS NULL OR v.currency = p_currency)
        AND v.price_list = best_level
    ) s
  ) r
  WHERE r.rn = 2;

  -- 4) Empate estricto: misma recencia exacta
  IF r2 IS NOT NULL
     AND coalesce(r1.valid_from, to_timestamp(0)) = coalesce(r2.valid_from, to_timestamp(0))
     AND r1.created_at = r2.created_at THEN
    RAISE EXCEPTION 'AMBIGUOUS_PRICE: múltiples precios vigentes con misma prioridad y recencia para sku %', p_sku
      USING ERRCODE = 'P0001';
  END IF;

  -- 5) Emitir ganador
  stripe_price_id := r1.stripe_price_id;
  amount_cents    := r1.amount_cents;
  currency        := r1.currency;
  metadata        := r1.metadata;
  RETURN NEXT;
END;
$function$

CREATE OR REPLACE FUNCTION public.f_orders_parse_keys(p_obj jsonb, p_event_type text)
 RETURNS TABLE(session_id text, invoice_id text, subscription_id text)
 LANGUAGE plpgsql
 STRICT SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
DECLARE
  v_event_type text;
BEGIN
  v_event_type := lower(trim(p_event_type));

  IF v_event_type = 'checkout.session.completed' THEN
    session_id      := nullif(p_obj->>'id', '');
    invoice_id      := nullif(p_obj->>'invoice', '');
    subscription_id := nullif(p_obj->>'subscription', '');

  ELSIF v_event_type = 'invoice.payment_succeeded' THEN
    session_id      := NULL;                                -- no aplica
    invoice_id      := nullif(p_obj->>'id', '');            -- in_...
    IF invoice_id IS NULL THEN
      invoice_id := nullif(p_obj->>'invoice', '');          -- fallback
    END IF;
    subscription_id := nullif(p_obj->>'subscription', '');

  ELSE
    RAISE EXCEPTION 'INVALID_EVENT';
  END IF;

  IF session_id IS NULL AND invoice_id IS NULL AND subscription_id IS NULL THEN
    RAISE EXCEPTION 'INVALID_KEYS';
  END IF;

  RETURN QUERY SELECT session_id, invoice_id, subscription_id;
END;
$function$

CREATE OR REPLACE FUNCTION public.f_orders_parse_payment(p_obj jsonb)
 RETURNS TABLE(amount_cents integer, currency text)
 LANGUAGE plpgsql
 STRICT SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
DECLARE
  v_amount        integer;
  v_currency      text;
  v_lines_total   integer := 0;
  li              jsonb;
  v_unit_dec      numeric;
  v_qty           integer;
BEGIN
  -- Suma por líneas como último recurso (invoice/line_item)
  FOR li IN SELECT elem FROM jsonb_array_elements(p_obj #> '{lines,data}') AS t(elem)
  LOOP
    v_lines_total := v_lines_total
      + COALESCE(
          NULLIF(li->>'amount','')::int,
          NULLIF(li->>'amount_total','')::int,
          -- unit_amount_decimal * quantity (si viene en price_details)
          (
            CASE
              WHEN (li #>> '{pricing,price_details,unit_amount_decimal}') IS NOT NULL
                   AND (li->>'quantity') IS NOT NULL THEN
                ((li #>> '{pricing,price_details,unit_amount_decimal}')::numeric
                 * NULLIF(li->>'quantity','')::int)::int
              ELSE NULL
            END
          ),
          0
        );
  END LOOP;

  -- Monto en orden de preferencia:
  v_amount := COALESCE(
    NULLIF(p_obj->>'amount_total','')::int,  -- checkout.session
    NULLIF(p_obj->>'amount_paid','')::int,   -- invoice
    NULLIF(p_obj->>'total','')::int,         -- invoice total
    NULLIF(p_obj->>'amount_due','')::int,    -- invoice due
    NULLIF(p_obj->>'subtotal','')::int,      -- invoice subtotal
    v_lines_total                             -- suma de líneas
  );

  -- Moneda normalizada con fallbacks a líneas
  v_currency := lower(trim(NULLIF(p_obj->>'currency','')));
  IF v_currency IS NULL OR v_currency = '' THEN
    v_currency := lower(trim(NULLIF((p_obj #> '{lines,data,0}') ->> 'currency','')));
  END IF;
  IF v_currency IS NULL OR v_currency = '' THEN
    v_currency := lower(trim(NULLIF((p_obj #> '{lines,data,0,price}') ->> 'currency','')));
  END IF;

  IF v_amount IS NULL OR v_amount <= 0 OR v_currency IS NULL OR v_currency = '' THEN
    RAISE EXCEPTION 'INVALID_PAYMENT';
  END IF;

  RETURN QUERY SELECT v_amount, v_currency;
END;
$function$

CREATE OR REPLACE FUNCTION public.f_orders_parse_metadata(p_obj jsonb)
 RETURNS TABLE(sku text, fulfillment_type text)
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
DECLARE
  v_md        jsonb;
  v_price_id  text;
  v_sku       text;
  v_ft        text;
BEGIN
  -- 1) Metadata directo: PRICE → PRODUCT
  v_md := coalesce(
    -- checkout.session
    p_obj->'line_items'->'data'->0->'price'->'metadata',
    p_obj->'line_items'->0->'price'->'metadata',
    p_obj->'line_items'->'data'->0->'pricing'->'price_details'->'price'->'metadata',
    p_obj->'line_items'->0->'pricing'->'price_details'->'price'->'metadata',

    -- invoice.payment_succeeded
    p_obj->'lines'->'data'->0->'price'->'metadata',
    p_obj->'lines'->0->'price'->'metadata',
    p_obj->'lines'->'data'->0->'pricing'->'price_details'->'price'->'metadata',
    p_obj->'lines'->0->'pricing'->'price_details'->'price'->'metadata',

    -- PRODUCT fallback
    p_obj->'line_items'->'data'->0->'price'->'product'->'metadata',
    p_obj->'line_items'->0->'price'->'product'->'metadata',
    p_obj->'line_items'->'data'->0->'pricing'->'price_details'->'price'->'product'->'metadata',
    p_obj->'line_items'->0->'pricing'->'price_details'->'price'->'product'->'metadata',

    p_obj->'lines'->'data'->0->'price'->'product'->'metadata',
    p_obj->'lines'->0->'price'->'product'->'metadata',
    p_obj->'lines'->'data'->0->'pricing'->'price_details'->'price'->'product'->'metadata',
    p_obj->'lines'->0->'pricing'->'price_details'->'price'->'product'->'metadata',
    '{}'::jsonb
  );

  v_sku := nullif(trim(v_md->>'sku'), '');
  v_ft  := lower(trim(nullif(v_md->>'fulfillment_type','')));

  IF v_sku IS NOT NULL AND v_ft IN ('course','template','live_class','one_to_one','subscription_grant','bundle') THEN
    RETURN QUERY SELECT v_sku, v_ft;
  END IF;

  -- 2) Fallback por price_id (price.id o pricing.price_details.price)
  v_price_id := coalesce(
    -- checkout.session
    p_obj->'line_items'->'data'->0->'price'->>'id',
    p_obj->'line_items'->0->'price'->>'id',
    p_obj->'line_items'->'data'->0->'pricing'->'price_details'->>'price',
    p_obj->'line_items'->0->'pricing'->'price_details'->>'price',
    -- invoice
    p_obj->'lines'->'data'->0->'price'->>'id',
    p_obj->'lines'->0->'price'->>'id',
    p_obj->'lines'->'data'->0->'pricing'->'price_details'->>'price',
    p_obj->'lines'->0->'pricing'->'price_details'->>'price',
    NULL
  );

  IF v_price_id IS NOT NULL THEN
    -- 2A) product_prices
    SELECT
      coalesce(pp.sku, nullif(trim(pp.metadata->>'sku'), '')),
      lower(trim(nullif(pp.metadata->>'fulfillment_type','')))
    INTO v_sku, v_ft
    FROM product_prices pp
    WHERE pp.stripe_price_id = v_price_id
    ORDER BY pp.created_at DESC
    LIMIT 1;

    -- 2B) v_prices_vigente
    IF v_sku IS NULL OR v_ft IS NULL OR v_ft NOT IN ('course','template','live_class','one_to_one','subscription_grant','bundle') THEN
      BEGIN
        SELECT
          v.sku,
          lower(trim(coalesce(v.metadata->>'fulfillment_type','')))
        INTO v_sku, v_ft
        FROM v_prices_vigente v
        WHERE v.stripe_price_id = v_price_id
        ORDER BY v.created_at DESC
        LIMIT 1;
      EXCEPTION WHEN undefined_table THEN NULL;
      END;
    END IF;
  END IF;

  -- 3) Validaciones finales
  IF v_sku IS NULL OR v_sku = '' THEN
    RAISE EXCEPTION 'INVALID_METADATA_PRICE: missing sku for price_id=%', coalesce(v_price_id,'<NULL>');
  END IF;

  IF v_ft NOT IN ('course','template','live_class','one_to_one','subscription_grant','bundle') THEN
    RAISE EXCEPTION 'INVALID_FULFILLMENT: fulfillment_type=% for price_id=%', coalesce(v_ft,'<null>'), coalesce(v_price_id,'<NULL>');
  END IF;

  RETURN QUERY SELECT v_sku, v_ft;
END;
$function$

CREATE OR REPLACE FUNCTION public.f_orders_resolve_user(p_obj jsonb)
 RETURNS uuid
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
DECLARE
  v_email   text;
  v_user_id uuid;
BEGIN
  -- Extrae y normaliza email desde el payload de Stripe
  v_email := lower(trim(coalesce(
    p_obj->'customer_details'->>'email',
    p_obj->>'customer_email',
    ''
  )));

  -- Wrapper neutro: si email vacío o inválido, devuelve NULL
  IF v_email = '' OR v_email !~* '^[A-Z0-9._%+-]+@[A-Z0-9.-]+\.[A-Z]{2,}$' THEN
    RETURN NULL;
  END IF;

  -- Resuelve user_id; f_auth_get_user retorna UUID o NULL
  v_user_id := public.f_auth_get_user(v_email);

  RETURN v_user_id;
END;
$function$

CREATE OR REPLACE FUNCTION public.f_orders_new_order_number()
 RETURNS text
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$declare
  v_seq bigint;
begin
  v_seq := nextval('public.seq_order_headers_order_number');
  return 'ORD-' |lpad(v_seq::text, 6, '0'); -- cumple ^ORD-\d{6}$;
end;$function$

CREATE OR REPLACE FUNCTION public.f_order_headers_upsert(p_user_id uuid, p_total_cents integer, p_currency text, p_status text DEFAULT 'paid'::text, p_stripe_session_id text DEFAULT NULL::text, p_stripe_invoice_id text DEFAULT NULL::text, p_stripe_subscription_id text DEFAULT NULL::text, p_stripe_payment_intent_id text DEFAULT NULL::text, p_stripe_customer_id text DEFAULT NULL::text, p_metadata jsonb DEFAULT '{}'::jsonb)
 RETURNS uuid
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
declare
  v_order_id     uuid;
  v_attempt      int  := 0;
  v_constraint   text;
  v_order_number text;
begin
  -- Validaciones mínimas
  if p_total_cents is null or p_total_cents <= 0 then
    raise exception 'INVALID_TOTAL_CENTS';
  end if;

  if coalesce(trim(p_currency),'') = '' then
    raise exception 'INVALID_CURRENCY';
  end if;

  if lower(p_status) not in ('paid','refunded','canceled','unpaid') then
    raise exception 'INVALID_STATUS';
  end if;

  -- Buscar orden existente por cualquier clave de Stripe
  select oh.id
    into v_order_id
  from public.order_headers oh
  where (p_stripe_session_id         is not null and oh.stripe_session_id         = p_stripe_session_id)
     or (p_stripe_invoice_id         is not null and oh.stripe_invoice_id         = p_stripe_invoice_id)
     or (p_stripe_subscription_id    is not null and oh.stripe_subscription_id    = p_stripe_subscription_id)
     or (p_stripe_payment_intent_id  is not null and oh.stripe_payment_intent_id  = p_stripe_payment_intent_id)
  order by oh.created_at
  limit 1;

  if v_order_id is not null then
    -- UPDATE: completar datos faltantes; no tocar order_number
    update public.order_headers oh
       set total_cents               = coalesce(oh.total_cents, p_total_cents),
           currency                  = coalesce(oh.currency, lower(p_currency)),
           status                    = case when oh.status = 'paid' then oh.status else lower(p_status) end,
           stripe_session_id         = coalesce(oh.stripe_session_id, p_stripe_session_id),
           stripe_invoice_id         = coalesce(oh.stripe_invoice_id, p_stripe_invoice_id),
           stripe_subscription_id    = coalesce(oh.stripe_subscription_id, p_stripe_subscription_id),
           stripe_payment_intent_id  = coalesce(oh.stripe_payment_intent_id, p_stripe_payment_intent_id),
           stripe_customer_id        = coalesce(oh.stripe_customer_id, p_stripe_customer_id),
           metadata                  = coalesce(oh.metadata, '{}'::jsonb) |coalesce(p_metadata, '{}'::jsonb),
           updated_at                = now()
     where oh.id = v_order_id;

  else
    -- INSERT con retry por colisión de order_number
    loop
      v_attempt := v_attempt + 1;
      begin
        v_order_number := public.f_orders_new_order_number();

        insert into public.order_headers (
          id,
          user_id,
          order_number,
          total_cents,
          currency,
          status,
          stripe_session_id,
          stripe_invoice_id,
          stripe_subscription_id,
          stripe_payment_intent_id,
          stripe_customer_id,
          metadata,
          created_at,
          updated_at
        )
        values (
          gen_random_uuid(),
          p_user_id,
          v_order_number,
          p_total_cents,
          lower(p_currency),
          lower(p_status),
          p_stripe_session_id,
          p_stripe_invoice_id,
          p_stripe_subscription_id,
          p_stripe_payment_intent_id,
          p_stripe_customer_id,
          coalesce(p_metadata,'{}'::jsonb),
          now(),
          null
        )
        returning id into v_order_id;

        exit; -- éxito

      exception when unique_violation then
        get stacked diagnostics v_constraint = constraint_name;
        if v_constraint = 'ux_order_headers_order_number' and v_attempt < 3 then
          -- reintenta con un nuevo número
          continue;
        else
          raise;
        end if;
      end;
    end loop;
  end if;

  return v_order_id;
end;
$function$

CREATE OR REPLACE FUNCTION public.f_payments_upsert(p_user_id uuid, p_obj jsonb, p_order_id uuid DEFAULT NULL::uuid)
 RETURNS uuid
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
DECLARE
  v_payment_id           uuid;
  v_invoice_id           text;
  v_payment_intent_id    text;
  v_subscription_id      text;
  v_customer_id          text;
  v_total_cents          int;
  v_currency             text;
  v_period_start_txt     text;
  v_period_end_txt       text;
  v_period_start         timestamptz;
  v_period_end           timestamptz;
  v_sku                  text;
  v_fulfillment_type     text;
  v_price_id             text;
  v_md                   jsonb;
BEGIN
  IF p_user_id IS NULL THEN RAISE EXCEPTION 'INVALID_USER'; END IF;
  IF p_obj    IS NULL THEN RAISE EXCEPTION 'INVALID_OBJECT'; END IF;

  -- Claves base
  v_invoice_id        := NULLIF(p_obj->>'id','');
  v_payment_intent_id := NULLIF(p_obj->>'payment_intent','');
  v_subscription_id   := NULLIF(p_obj->>'subscription','');
  v_customer_id       := NULLIF(COALESCE(p_obj->>'customer', p_obj->'customer_details'->>'id'), '');

  -- Importe robusto
  v_total_cents := NULL;  v_currency := NULL;
  BEGIN
    SELECT amount_cents, currency
      INTO v_total_cents, v_currency
    FROM public.f_orders_parse_payment($2);
  EXCEPTION WHEN OTHERS THEN
    -- fallback
  END;
  IF COALESCE(v_total_cents,0) <= 0 OR v_currency IS NULL OR v_currency='' THEN
    v_total_cents := COALESCE(
      NULLIF($2->>'amount_total','')::int,
      NULLIF($2->>'amount_paid','')::int,
      NULLIF($2->>'total','')::int,
      NULLIF($2->>'amount_due','')::int,
      NULLIF($2->>'subtotal','')::int
    );
    v_currency := lower(trim(NULLIF($2->>'currency','')));
    IF COALESCE(v_total_cents,0) <= 0 OR v_currency IS NULL OR v_currency='' THEN
      RAISE EXCEPTION 'INVALID_PAYMENT';
    END IF;
  END IF;

  -- Periodo
  v_period_start_txt := $2->'lines'->'data'->0->'period'->>'start';
  v_period_end_txt   := $2->'lines'->'data'->0->'period'->>'end';
  IF v_period_start_txt ~ '^\d+(\.\d+)?$' THEN
    v_period_start := to_timestamp(v_period_start_txt::double precision);
  ELSIF v_period_start_txt IS NOT NULL AND v_period_start_txt <> '' THEN
    BEGIN v_period_start := v_period_start_txt::timestamptz; EXCEPTION WHEN OTHERS THEN v_period_start := NULL; END;
  END IF;
  IF v_period_end_txt ~ '^\d+(\.\d+)?$' THEN
    v_period_end := to_timestamp(v_period_end_txt::double precision);
  ELSIF v_period_end_txt IS NOT NULL AND v_period_end_txt <> '' THEN
    BEGIN v_period_end := v_period_end_txt::timestamptz; EXCEPTION WHEN OTHERS THEN v_period_end := NULL; END;
  END IF;

  -- SKU y fulfillment_type (usa función con fallback a product_prices)
  BEGIN
    SELECT sku, fulfillment_type
      INTO v_sku, v_fulfillment_type
    FROM public.f_orders_parse_metadata($2);
  EXCEPTION WHEN OTHERS THEN
    v_sku := NULLIF(COALESCE(
      $2#>>'{lines,data,0,price,metadata,sku}',
      $2#>>'{lines,data,0,price,product,metadata,sku}'
    ), '');
    v_fulfillment_type := NULLIF(COALESCE(
      $2#>>'{lines,data,0,price,metadata,fulfillment_type}',
      $2#>>'{lines,data,0,price,product,metadata,fulfillment_type}'
    ), '');
  END;
  IF v_sku IS NULL OR v_sku='' OR v_fulfillment_type IS NULL OR v_fulfillment_type='' THEN
    RAISE EXCEPTION 'INVALID_METADATA';
  END IF;

  -- price_id robusto: soporta objetos expandidos y payloads compactos
  v_price_id := COALESCE(
    NULLIF($2->'lines'->'data'->0->'price'->>'id',''),
    NULLIF($2->'lines'->'data'->0->'pricing'->'price_details'->>'price',''),
    NULLIF($2->'line_items'->'data'->0->'price'->>'id',''),
    NULLIF($2->'line_items'->'data'->0->'pricing'->'price_details'->>'price','')
  );

  -- Metadata combinada
  v_md := COALESCE($2->'metadata','{}'::jsonb)
          |jsonb_build_object(
               'sku', v_sku,
               'fulfillment_type', v_fulfillment_type,
               'subscription_id', v_subscription_id,
               'customer_id', v_customer_id
             );
  IF v_price_id IS NOT NULL AND v_price_id <> '' THEN
    v_md := v_md |jsonb_build_object('price_id', v_price_id);
  END IF;

  -- Upsert por invoice / payment_intent
  SELECT id INTO v_payment_id
  FROM public.payments
  WHERE (v_invoice_id IS NOT NULL AND stripe_invoice_id = v_invoice_id)
     OR (v_payment_intent_id IS NOT NULL AND stripe_payment_intent_id = v_payment_intent_id)
  LIMIT 1;

  IF v_payment_id IS NULL THEN
    INSERT INTO public.payments (
      user_id, order_id, total_cents, currency, status,
      stripe_invoice_id, stripe_payment_intent_id,
      stripe_subscription_id, stripe_customer_id, stripe_charge_id,
      period_start, period_end, metadata
    )
    VALUES (
      p_user_id, p_order_id, v_total_cents, v_currency, 'paid',
      v_invoice_id, v_payment_intent_id,
      v_subscription_id, v_customer_id, NULL,
      v_period_start, v_period_end, v_md
    )
    RETURNING id INTO v_payment_id;
  ELSE
    UPDATE public.payments
       SET user_id                  = p_user_id,
           order_id                 = COALESCE(p_order_id, order_id),
           total_cents              = v_total_cents,
           currency                 = v_currency,
           status                   = 'paid',
           stripe_invoice_id        = COALESCE(v_invoice_id, stripe_invoice_id),
           stripe_payment_intent_id = COALESCE(v_payment_intent_id, stripe_payment_intent_id),
           stripe_subscription_id   = COALESCE(v_subscription_id, stripe_subscription_id),
           stripe_customer_id       = COALESCE(v_customer_id, stripe_customer_id),
           period_start             = COALESCE(v_period_start, period_start),
           period_end               = COALESCE(v_period_end, period_end),
           metadata                 = metadata |v_md,
           updated_at               = now()
     WHERE id = v_payment_id
     RETURNING id INTO v_payment_id;
  END IF;

  RETURN v_payment_id;
END;
$function$

CREATE OR REPLACE FUNCTION public.f_payments_upsert_by_session(p_payment_intent jsonb, p_session jsonb, p_order_id uuid DEFAULT NULL::uuid)
 RETURNS TABLE(payment_id uuid, order_id uuid)
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
DECLARE
  v_user_id    uuid;
  v_session_id text;
  v_pi_id      text;
  v_order_id   uuid;
  v_pid        uuid;
  v_obj_norm   jsonb;
BEGIN
  IF p_session IS NULL THEN RAISE EXCEPTION 'INVALID_SESSION'; END IF;
  IF p_payment_intent IS NULL THEN RAISE EXCEPTION 'INVALID_OBJECT'; END IF;

  v_user_id := public.f_orders_resolve_user(p_session);
  IF v_user_id IS NULL THEN RAISE EXCEPTION 'USER_NOT_FOUND_FROM_SESSION'; END IF;

  v_obj_norm :=
    (p_payment_intent - 'id')
    |jsonb_build_object(
         'payment_intent', p_payment_intent->>'id',
         'amount_total',   COALESCE((p_payment_intent->>'amount_received')::int, (p_payment_intent->>'amount')::int),
         'currency',       lower(NULLIF(p_payment_intent->>'currency','')),
         'line_items', jsonb_build_object(
           'data', jsonb_build_array(
             jsonb_build_object(
               'price', jsonb_build_object(
                 'id', NULLIF(p_session->'metadata'->>'price_id',''),
                 'metadata', jsonb_build_object(
                   'sku',               NULLIF(p_session->'metadata'->>'sku',''),
                   'fulfillment_type',  NULLIF(p_session->'metadata'->>'fulfillment_type','')
                 )
               )
             )
           )
         )
       );

  v_order_id := p_order_id;
  v_session_id := NULLIF(p_session->>'id','');
  v_pi_id      := NULLIF(p_payment_intent->>'id','');

  IF v_order_id IS NULL AND v_session_id IS NOT NULL THEN
    SELECT oh.id INTO v_order_id
    FROM public.order_headers oh
    WHERE oh.stripe_session_id = v_session_id
    ORDER BY oh.created_at DESC
    LIMIT 1;
  END IF;

  IF v_order_id IS NULL AND v_pi_id IS NOT NULL THEN
    SELECT oh.id INTO v_order_id
    FROM public.order_headers oh
    WHERE oh.stripe_payment_intent_id = v_pi_id
       OR oh.metadata->>'payment_intent' = v_pi_id
    ORDER BY oh.created_at DESC
    LIMIT 1;
  END IF;

  v_pid := public.f_payments_upsert(v_user_id, v_obj_norm, v_order_id);

  -- Emitir la fila:
  RETURN QUERY SELECT v_pid, v_order_id;
END;
$function$

CREATE OR REPLACE FUNCTION public.f_entitlements_grant(p_user_id uuid, p_sku text, p_fulfillment_type text, p_source_type text, p_source_id text, p_metadata jsonb DEFAULT '{}'::jsonb, p_valid_until timestamp with time zone DEFAULT NULL::timestamp with time zone, p_actor text DEFAULT 'system:backend'::text)
 RETURNS uuid
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$declare
  v_id uuid;
  v_existing_active uuid;
  v_has_events boolean;
  v_source_id_is_uuid boolean;
  v_source_type entitlement_source_type;
begin
  -- Validaciones
  if p_user_id is null
     or coalesce(trim(p_sku),'') = ''
     or coalesce(trim(p_fulfillment_type),'') = ''
     or coalesce(trim(p_source_type),'') = ''
     or coalesce(trim(p_source_id),'') = '' then
    raise exception 'INVALID_ARGUMENT';
  end if;

  p_sku := lower(p_sku);
  p_fulfillment_type := lower(p_fulfillment_type);

  if p_fulfillment_type = 'bundle' then
    raise exception 'BUNDLE_NOT_SUPPORTED';
  end if;

  if p_fulfillment_type not in ('course','template','live_class','one_to_one','subscription_grant') then
    raise exception 'INVALID_FULFILLMENT_TYPE';
  end if;

  -- Enum de source_type
  v_source_type := p_source_type::entitlement_source_type;

  -- Tipo real de source_id en la tabla
  select (c.data_type = 'uuid')
  into v_source_id_is_uuid
  from information_schema.columns c
  where c.table_schema='public' and c.table_name='entitlements' and c.column_name='source_id';

  -- ¿Existe entitlement_events?
  select exists (
    select 1
    from pg_catalog.pg_class c
    join pg_catalog.pg_namespace n on n.oid = c.relnamespace
    where n.nspname = 'public' and c.relname = 'entitlement_events' and c.relkind = 'r'
  ) into v_has_events;

  -- Idempotencia exacta por (user, sku, source_type, source_id)
  select id
    into v_id
  from entitlements
  where user_id = p_user_id
    and sku = p_sku
    and source_type = v_source_type
    and source_id::text = p_source_id
  limit 1;

  if v_id is not null then
    -- Reactivar si estaba inactivo
    if exists (select 1 from entitlements where id = v_id and active is not true) then
      update entitlements
         set active = true,
             revoked_at = null,
             valid_until = coalesce(p_valid_until, valid_until),
             metadata = coalesce(metadata,'{}'::jsonb) |coalesce(p_metadata,'{}'::jsonb),
             updated_at = now()
       where id = v_id;

      if v_has_events then
        begin
          insert into entitlement_events (id, entitlement_id, type, actor, payload, created_at)
          values (
            gen_random_uuid(), v_id, 'restore', p_actor,
            jsonb_build_object(
              'user_id', p_user_id, 'sku', p_sku,
              'source_type', p_source_type, 'source_id', p_source_id
            ),
            now()
          );
        exception when others then null;
        end;
      end if;
    end if;

    return v_id;
  end if;

  -- Evitar más de un activo por (user, sku)
  select id
    into v_existing_active
  from entitlements
  where user_id = p_user_id
    and sku = p_sku
    and active is true
  limit 1;

  if v_existing_active is not null then
    raise exception 'ACTIVE_CONFLICT:%', v_existing_active;
  end if;

  -- INSERT nuevo grant (ramificando por tipo de source_id para evitar CASE mixto)
  if v_source_id_is_uuid then
    insert into entitlements (
        id, user_id, sku, fulfillment_type, source_type, source_id,
        metadata, active, valid_until
    ) values (
        gen_random_uuid(),
        p_user_id,
        p_sku,
        p_fulfillment_type,
        v_source_type,
        p_source_id::uuid,
        coalesce(p_metadata,'{}'::jsonb),
        true,
        p_valid_until
    )
    returning id into v_id;
  else
    insert into entitlements (
        id, user_id, sku, fulfillment_type, source_type, source_id,
        metadata, active, valid_until
    ) values (
        gen_random_uuid(),
        p_user_id,
        p_sku,
        p_fulfillment_type,
        v_source_type,
        p_source_id, -- text
        coalesce(p_metadata,'{}'::jsonb),
        true,
        p_valid_until
    )
    returning id into v_id;
  end if;

  -- Evento grant
  if v_has_events then
    begin
      insert into entitlement_events (id, entitlement_id, type, actor, payload, created_at)
      values (
        gen_random_uuid(), v_id, 'grant', p_actor,
        jsonb_build_object(
          'user_id', p_user_id, 'sku', p_sku,
          'source_type', p_source_type, 'source_id', p_source_id
        ),
        now()
      );
    exception when others then null;
    end;
  end if;

  return v_id;

exception
  when unique_violation then
    select id into v_existing_active
    from entitlements
    where user_id = p_user_id and sku = p_sku and active is true
    limit 1;
    if v_existing_active is not null then
      raise exception 'ACTIVE_CONFLICT:%', v_existing_active;
    else
      raise;
    end if;
end;
$function$

CREATE OR REPLACE FUNCTION public.f_entitlements_renew_subscription(p_entitlement_id uuid, p_metadata jsonb DEFAULT '{}'::jsonb, p_valid_until timestamp with time zone DEFAULT NULL::timestamp with time zone, p_actor text DEFAULT 'system:backend'::text, p_was_existing boolean DEFAULT true)
 RETURNS timestamp with time zone
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
DECLARE
  v_prev_valid     timestamptz;
  v_target_valid   timestamptz;
  v_invoice_id     text;

  -- Ciclo desde metadata; fallback 1 month
  v_interval_unit  text;
  v_interval_count int;
  v_cycle          interval;
  v_base           timestamptz;
BEGIN
  IF p_entitlement_id IS NULL THEN
    RAISE EXCEPTION 'INVALID_ENTITLEMENT';
  END IF;

  v_invoice_id := nullif(p_metadata->>'invoice_id','');

  -- Configurar ciclo
  v_interval_unit  := lower(nullif(p_metadata->>'recurring_interval',''));
  v_interval_count := COALESCE((nullif(p_metadata->>'interval_count',''))::int, 1);
  IF v_interval_unit NOT IN ('day','week','month','year') THEN v_interval_unit := 'month'; END IF;
  IF v_interval_count <= 0 THEN v_interval_count := 1; END IF;
  v_cycle := (v_interval_count |' ' |v_interval_unit)::interval;

  -- Vigencia objetivo: desde period_end si viene, si no desde base + ciclo
  SELECT valid_until INTO v_prev_valid
  FROM public.entitlements
  WHERE id = p_entitlement_id;

  v_base := GREATEST(now(), COALESCE(v_prev_valid, now()));
  v_target_valid := COALESCE(p_valid_until, v_base + v_cycle);

  IF v_prev_valid IS DISTINCT FROM v_target_valid THEN
    UPDATE public.entitlements
       SET valid_until = v_target_valid,
           updated_at  = now()
     WHERE id = p_entitlement_id;
  END IF;

  -- Evento renew idempotente por invoice_id
  IF p_was_existing THEN
    IF v_invoice_id IS NULL OR NOT EXISTS (
         SELECT 1 FROM public.entitlement_events ee
         WHERE ee.entitlement_id = p_entitlement_id
           AND ee.type = 'renew'
           AND (ee.payload->>'invoice_id') = v_invoice_id
       ) THEN
      INSERT INTO public.entitlement_events(entitlement_id, type, actor, payload, created_at)
      VALUES (
        p_entitlement_id,
        'renew',
        coalesce(p_actor,'system:backend'),
        coalesce(p_metadata,'{}'::jsonb) |jsonb_build_object('valid_until', v_target_valid),
        now()
      );
    END IF;
  END IF;

  RETURN v_target_valid;
END;
$function$

CREATE OR REPLACE FUNCTION public.f_entitlements_apply(p_user_id uuid, p_order_id uuid, p_sku text, p_fulfillment_type text, p_metadata jsonb DEFAULT '{}'::jsonb, p_valid_until timestamp with time zone DEFAULT NULL::timestamp with time zone, p_actor text DEFAULT 'system:backend'::text)
 RETURNS uuid
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
DECLARE
  v_entitlement_id uuid;
  v_first_id       uuid;
  v_sku            text;
  v_ft             text;
  v_child          record;
  v_msg            text;
  v_conflict_id    uuid;
  v_was_existing   boolean;
  v_merged         boolean;
  v_has_events     boolean;
BEGIN
  -- Validaciones
  v_sku := nullif(trim(coalesce(p_sku,'')),'');
  IF v_sku IS NULL THEN RAISE EXCEPTION 'INVALID_SKU'; END IF;

  v_ft := lower(trim(coalesce(p_fulfillment_type,'')));
  IF v_ft NOT IN ('course','template','live_class','one_to_one','subscription_grant','bundle') THEN
    RAISE EXCEPTION 'INVALID_FULFILLMENT';
  END IF;

  -- ¿Existe tabla de eventos?
  SELECT EXISTS (
    SELECT 1
    FROM pg_class c
    JOIN pg_namespace n ON n.oid = c.relnamespace
    WHERE n.nspname='public' AND c.relname='entitlement_events' AND c.relkind='r'
  ) INTO v_has_events;

  ---------------------------------------------------------------------------
  -- 1) BUNDLE
  ---------------------------------------------------------------------------
  IF v_ft = 'bundle' THEN
    FOR v_child IN
      SELECT sku, fulfillment_type FROM public.f_bundles_expand_items(v_sku)
    LOOP
      v_was_existing := false;
      v_merged := false;
      v_entitlement_id := NULL;

      -- existente activo
      SELECT e.id
        INTO v_entitlement_id
      FROM public.entitlements e
      WHERE e.user_id = p_user_id
        AND e.sku = v_child.sku
        AND e.active
      ORDER BY e.created_at DESC
      LIMIT 1;

      IF v_entitlement_id IS NOT NULL THEN
        v_was_existing := true;

        -- MERGE inmediato
        UPDATE public.entitlements
           SET metadata    = coalesce(metadata,'{}'::jsonb) |(coalesce(p_metadata,'{}'::jsonb) |jsonb_build_object('bundle_parent', v_sku)),
               valid_until = coalesce(p_valid_until, valid_until),
               updated_at  = now()
         WHERE id = v_entitlement_id;
        v_merged := true;

        IF v_has_events THEN
          BEGIN
            INSERT INTO entitlement_events (id, entitlement_id, type, actor, payload, created_at)
            VALUES (
              gen_random_uuid(), v_entitlement_id, 'update', p_actor,
              jsonb_build_object('user_id', p_user_id, 'sku', v_child.sku, 'source_type','order','source_id', p_order_id::text),
              now()
            );
          EXCEPTION WHEN OTHERS THEN NULL; END;
        END IF;

      ELSE
        -- Intentar grant
        BEGIN
          v_entitlement_id := public.f_entitlements_grant(
            p_user_id,
            v_child.sku,
            v_child.fulfillment_type,
            'order',
            p_order_id::text,
            coalesce(p_metadata,'{}'::jsonb) |jsonb_build_object('bundle_parent', v_sku),
            p_valid_until,
            coalesce(p_actor,'system:backend')
          );
        EXCEPTION WHEN OTHERS THEN
          v_msg := sqlerrm;
          IF position('ACTIVE_CONFLICT:' IN v_msg) > 0 THEN
            v_conflict_id := substring(v_msg FROM 'ACTIVE_CONFLICT:([0-9a-f-]{36})')::uuid;
            v_entitlement_id := v_conflict_id;
            v_was_existing := true;
            -- NOTA: aún no merged; se hará en el post-merge uniforme abajo.
          ELSE
            RAISE;
          END IF;
        END;
      END IF;

      -- Post-merge uniforme para conflictos
      IF v_was_existing AND NOT v_merged AND v_entitlement_id IS NOT NULL THEN
        UPDATE public.entitlements
           SET metadata    = coalesce(metadata,'{}'::jsonb) |(coalesce(p_metadata,'{}'::jsonb) |jsonb_build_object('bundle_parent', v_sku)),
               valid_until = coalesce(p_valid_until, valid_until),
               updated_at  = now()
         WHERE id = v_entitlement_id;

        IF v_has_events THEN
          BEGIN
            INSERT INTO entitlement_events (id, entitlement_id, type, actor, payload, created_at)
            VALUES (
              gen_random_uuid(), v_entitlement_id, 'update', p_actor,
              jsonb_build_object('user_id', p_user_id, 'sku', v_child.sku, 'source_type','order','source_id', p_order_id::text),
              now()
            );
          EXCEPTION WHEN OTHERS THEN NULL; END;
        END IF;
      END IF;

      -- Renovación suscripción en bundle
      IF v_child.fulfillment_type = 'subscription_grant' AND v_entitlement_id IS NOT NULL THEN
        PERFORM public.f_entitlements_renew_subscription(
          p_entitlement_id := v_entitlement_id,
          p_metadata       := coalesce(p_metadata,'{}'::jsonb),
          p_valid_until    := p_valid_until,
          p_actor          := coalesce(p_actor,'system:backend'),
          p_was_existing   := v_was_existing
        );
      END IF;

      IF v_first_id IS NULL AND v_entitlement_id IS NOT NULL THEN
        v_first_id := v_entitlement_id;
      END IF;
    END LOOP;

    IF v_first_id IS NULL THEN
      RAISE EXCEPTION 'BUNDLE_EMPTY_OR_GRANT_FAILED';
    END IF;

    RETURN v_first_id;
  END IF;

  ---------------------------------------------------------------------------
  -- 2) NO-BUNDLE
  ---------------------------------------------------------------------------
  v_was_existing := false;
  v_merged := false;
  v_entitlement_id := NULL;

  -- existente activo
  SELECT e.id
    INTO v_entitlement_id
  FROM public.entitlements e
  WHERE e.user_id = p_user_id
    AND e.sku = v_sku
    AND e.active
  ORDER BY e.created_at DESC
  LIMIT 1;

  IF v_entitlement_id IS NOT NULL THEN
    v_was_existing := true;

    -- MERGE inmediato
    UPDATE public.entitlements
       SET metadata    = coalesce(metadata,'{}'::jsonb) |coalesce(p_metadata,'{}'::jsonb),
           valid_until = coalesce(p_valid_until, valid_until),
           updated_at  = now()
     WHERE id = v_entitlement_id;
    v_merged := true;

    IF v_has_events THEN
      BEGIN
        INSERT INTO entitlement_events (id, entitlement_id, type, actor, payload, created_at)
        VALUES (
          gen_random_uuid(), v_entitlement_id, 'update', p_actor,
          jsonb_build_object('user_id', p_user_id, 'sku', v_sku, 'source_type','order','source_id', p_order_id::text),
          now()
        );
      EXCEPTION WHEN OTHERS THEN NULL; END;
    END IF;

  ELSE
    -- GRANT nuevo
    BEGIN
      v_entitlement_id := public.f_entitlements_grant(
        p_user_id,
        v_sku,
        v_ft,
        'order',
        p_order_id::text,
        coalesce(p_metadata,'{}'::jsonb),
        p_valid_until,
        coalesce(p_actor,'system:backend')
      );
    EXCEPTION WHEN OTHERS THEN
      v_msg := sqlerrm;
      IF position('ACTIVE_CONFLICT:' IN v_msg) > 0 THEN
        v_conflict_id := substring(v_msg FROM 'ACTIVE_CONFLICT:([0-9a-f-]{36})')::uuid;
        v_entitlement_id := v_conflict_id;
        v_was_existing := true;
        -- NOTA: aún no merged; se hará en el post-merge uniforme abajo.
      ELSE
        RAISE;
      END IF;
    END;
  END IF;

  IF v_entitlement_id IS NULL THEN
    RAISE EXCEPTION 'GRANT_FAILED';
  END IF;

  -- Post-merge uniforme para conflictos
  IF v_was_existing AND NOT v_merged THEN
    UPDATE public.entitlements
       SET metadata    = coalesce(metadata,'{}'::jsonb) |coalesce(p_metadata,'{}'::jsonb),
           valid_until = coalesce(p_valid_until, valid_until),
           updated_at  = now()
     WHERE id = v_entitlement_id;

    IF v_has_events THEN
      BEGIN
        INSERT INTO entitlement_events (id, entitlement_id, type, actor, payload, created_at)
        VALUES (
          gen_random_uuid(), v_entitlement_id, 'update', p_actor,
          jsonb_build_object('user_id', p_user_id, 'sku', v_sku, 'source_type','order','source_id', p_order_id::text),
          now()
        );
      EXCEPTION WHEN OTHERS THEN NULL; END;
    END IF;
  END IF;

  -- Renovación para suscripciones
  IF v_ft = 'subscription_grant' THEN
    PERFORM public.f_entitlements_renew_subscription(
      p_entitlement_id := v_entitlement_id,
      p_metadata       := coalesce(p_metadata,'{}'::jsonb),
      p_valid_until    := p_valid_until,
      p_actor          := coalesce(p_actor,'system:backend'),
      p_was_existing   := v_was_existing
    );
  END IF;

  RETURN v_entitlement_id;
END;
$function$

CREATE OR REPLACE FUNCTION public.f_webhooks_log_event(p_stripe_event_id text, p_type text, p_payload jsonb)
 RETURNS void
 LANGUAGE plpgsql
 STRICT SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
begin
  -- Validaciones básicas
  if coalesce(trim(p_stripe_event_id), '') = '' then
    raise exception 'INVALID_STRIPE_EVENT_ID';
  end if;

  if coalesce(trim(p_type), '') = '' then
    raise exception 'INVALID_EVENT_TYPE';
  end if;

  if p_payload is null then
    raise exception 'INVALID_PAYLOAD';
  end if;

  -- Inserta solo si no existe (idempotencia por stripe_event_id)
  insert into public.webhook_events (stripe_event_id, type, payload, received_at)
  values (p_stripe_event_id, p_type, p_payload, now())
  on conflict (stripe_event_id) do nothing;
end;
$function$

CREATE OR REPLACE FUNCTION public.f_webhookevents_getbystripeid(p_stripe_event_id text)
 RETURNS webhook_events
 LANGUAGE plpgsql
 STABLE
 SET search_path TO 'pg_catalog', 'public'
AS $function$
declare
  v_row public.webhook_events%rowtype;
begin
  select *
    into v_row
  from public.webhook_events
  where stripe_event_id = p_stripe_event_id
  order by received_at desc
  limit 1;

  if not found then
    return null;
  end if;

  return v_row;
end;
$function$

CREATE OR REPLACE FUNCTION public.f_webhooks_mark_processed(p_stripe_event_id text, p_order_id uuid DEFAULT NULL::uuid)
 RETURNS void
 LANGUAGE plpgsql
 STRICT SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
declare
  v_rows int;
begin
  if coalesce(trim(p_stripe_event_id), '') = '' then
    raise exception 'INVALID_STRIPE_EVENT_ID';
  end if;

  update public.webhook_events
     set processed_at = coalesce(processed_at, now()),
         order_id     = coalesce(p_order_id, order_id)
   where stripe_event_id = p_stripe_event_id;

  get diagnostics v_rows = row_count;
  if v_rows = 0 then
    raise exception 'STRIPE_EVENT_NOT_FOUND';
  end if;
end;
$function$

CREATE OR REPLACE FUNCTION public.f_orch_contact_write_v1(p_input jsonb)
 RETURNS jsonb
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'pg_catalog', 'public', 'app'
AS $function$
declare
  v_in           jsonb := coalesce(p_input, '{}'::jsonb);
  v_norm         jsonb;
  v_contact_id   uuid;
  v_message_id   uuid;
  v_event_id     uuid;
  v_existing_msg uuid;
  v_status       text := 'ok';
  v_email        text;
  v_request_id   text;
  v_source_norm  text;
  v_opt_in       boolean;
  v_campaign_id  text := nullif(trim(coalesce(v_in->>'campaign_id','')), '');
begin
  -- 1) Normalizar y validar
  v_norm := app.f_contact_normalize_v1(v_in);
  perform app.f_contact_validate_v1(v_norm);

  v_email       := v_norm->>'email';
  v_request_id  := v_norm->>'request_id';
  v_source_norm := v_norm->>'source';
  v_opt_in      := case when (v_norm ? 'marketing_opt_in') then (v_norm->>'marketing_opt_in')::boolean else false end;

  -- 2) Upsert contacto
  v_contact_id := app.f_contacts_upsert_v1(v_norm);

  -- 3) Idempotencia mensaje
  select id into v_existing_msg
  from public.messages
  where contact_id = v_contact_id
    and metadata->>'request_id' = v_request_id
  for update;

  if found then
    v_status := 'duplicate';
    v_message_id := v_existing_msg;
  else
    v_message_id := app.f_messages_idempotent_v1(v_contact_id, v_norm);
  end if;

  -- 4) Evento de suscripción opcional
  if v_opt_in is true then
    v_event_id := app.f_subscription_events_log_v1(
      v_contact_id,
      jsonb_build_object(
        'event_type','opt_in',
        'source', v_source_norm,
        'campaign_id', v_campaign_id,
        'request_id', v_request_id
      )
    );
  else
    v_event_id := null;
  end if;

  -- 5) Respuesta
  return jsonb_build_object(
    'version','v1',
    'submission_id', v_request_id,
    'status', v_status,
    'contact', jsonb_build_object(
      'id', v_contact_id,
      'email', v_email,
      'consent_status', (select consent_status from public.contacts where id = v_contact_id)
    ),
    'message', jsonb_build_object('id', v_message_id),
    'subscription_event', jsonb_build_object(
      'id', v_event_id,
      'event_type', case when v_event_id is null then null else 'opt_in' end
    ),
    'warnings', '[]'::jsonb
  );
end;
$function$

CREATE OR REPLACE FUNCTION public.f_orch_contact_write(p_input jsonb)
 RETURNS jsonb
 LANGUAGE sql
 SECURITY DEFINER
 SET search_path TO 'public', 'pg_catalog', 'app'
AS $function$
  select public.f_orch_contact_write_v1(p_input);
$function$

CREATE OR REPLACE FUNCTION public.f_orch_orders_upsert(session_payload jsonb)
 RETURNS uuid
 LANGUAGE plpgsql
 STRICT SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
DECLARE
  v_event_id          text;
  v_type              text;
  v_obj               jsonb;

  v_user_id           uuid;

  v_session_id        text;
  v_invoice_id        text;
  v_subscription_id   text;

  v_amount_cents      int;
  v_currency          text;

  v_sku               text;
  v_fulfillment_type  text;

  v_order_id          uuid;

  v_processed_at      timestamptz;
  v_existing_order_id uuid;

  v_metadata          jsonb;
  v_payment_intent    text;
  v_customer          text;

  v_period_end_txt    text;
  v_period_end        timestamptz;
  v_interval_unit     text;
  v_interval_count    int;
  v_price_id          text;

  v_payment_id        uuid;
BEGIN
  -- 1) Validar inputs
  v_event_id := session_payload->>'stripe_event_id';
  v_type     := session_payload->>'type';
  IF v_event_id IS NULL OR v_event_id = '' OR v_type IS NULL OR v_type = '' THEN
    RAISE EXCEPTION 'INVALID_EVENT';
  END IF;
  IF v_type NOT IN ('checkout.session.completed','invoice.payment_succeeded') THEN
    RAISE EXCEPTION 'INVALID_EVENT';
  END IF;

  -- 2) Log e idempotencia
  PERFORM f_webhooks_log_event(v_event_id, v_type, session_payload);
  SELECT we.order_id, we.processed_at
    INTO v_existing_order_id, v_processed_at
  FROM webhook_events we
  WHERE we.stripe_event_id = v_event_id;
  IF v_processed_at IS NOT NULL AND v_existing_order_id IS NOT NULL THEN
    RETURN v_existing_order_id;
  END IF;

  -- 3) Extraer objeto
  v_obj := session_payload->'data'->'object';
  IF v_obj IS NULL THEN
    RAISE EXCEPTION 'INVALID_EVENT';
  END IF;

  -- 4) Resolver usuario
  v_user_id := f_orders_resolve_user(v_obj);
  IF v_user_id IS NULL THEN
    RAISE EXCEPTION 'NOT_FOUND_USER';
  END IF;

  -- 5) Parsear llaves
  SELECT session_id, invoice_id, subscription_id
    INTO v_session_id, v_invoice_id, v_subscription_id
  FROM f_orders_parse_keys(v_obj, v_type);
  IF v_session_id IS NULL AND v_invoice_id IS NULL AND v_subscription_id IS NULL THEN
    RAISE EXCEPTION 'INVALID_KEYS';
  END IF;

  -- 6) Parseo de pago
  v_amount_cents := NULL;
  v_currency := NULL;
  BEGIN
    SELECT amount_cents, currency
      INTO v_amount_cents, v_currency
    FROM public.f_orders_parse_payment(v_obj);
  EXCEPTION WHEN OTHERS THEN
    NULL;
  END;
  IF COALESCE(v_amount_cents, 0) <= 0 OR v_currency IS NULL OR v_currency = '' THEN
    v_amount_cents := COALESCE(
      NULLIF(v_obj->>'amount_total','')::int,
      NULLIF(v_obj->>'amount_paid','')::int,
      NULLIF(v_obj->>'total','')::int,
      NULLIF(v_obj->>'amount_due','')::int,
      NULLIF(v_obj->>'subtotal','')::int
    );
    v_currency := lower(trim(NULLIF(v_obj->>'currency','')));
    IF COALESCE(v_amount_cents, 0) <= 0 OR v_currency IS NULL OR v_currency = '' THEN
      RAISE EXCEPTION 'INVALID_PAYMENT';
    END IF;
  END IF;

  -- 7) Metadata base y atributos
  SELECT sku, fulfillment_type INTO v_sku, v_fulfillment_type
  FROM f_orders_parse_metadata(v_obj);
  IF v_sku IS NULL OR v_sku = '' OR v_fulfillment_type IS NULL OR v_fulfillment_type = '' THEN
    RAISE EXCEPTION 'INVALID_FULFILLMENT';
  END IF;

  -- price_id robusto
  v_price_id := COALESCE(
    NULLIF(v_obj->'line_items'->'data'->0->'price'->>'id',''),
    NULLIF(v_obj->'lines'->'data'->0->'price'->>'id',''),
    NULLIF(v_obj->'line_items'->'data'->0->'pricing'->'price_details'->>'price',''),
    NULLIF(v_obj->'lines'->'data'->0->'pricing'->'price_details'->>'price','')
  );

  -- Metadata unificado
  v_payment_intent := v_obj->>'payment_intent';
  v_customer       := COALESCE(v_obj->>'customer', (v_obj->'customer_details'->>'id'));
  v_metadata := COALESCE(v_obj->'metadata','{}'::jsonb)
                |jsonb_build_object(
                     'sku', v_sku,
                     'fulfillment_type', v_fulfillment_type,
                     'subscription_id', v_subscription_id,
                     'customer_id', v_customer,
                     'price_id', v_price_id
                   );

  ---------------------------------------------------------------------------
  -- 8) Ramas por tipo de evento
  ---------------------------------------------------------------------------
  IF v_type = 'checkout.session.completed' THEN
    -- 8A) Upsert de orden
    v_order_id := f_order_headers_upsert(
      v_user_id, v_amount_cents, v_currency, 'paid',
      v_session_id, v_invoice_id, v_subscription_id,
      v_payment_intent, v_customer, v_metadata
    );

    -- 9A) Conceder accesos
    PERFORM f_entitlements_apply(
      v_user_id, v_order_id, v_sku, v_fulfillment_type, v_metadata
    );

  ELSE
    -- 8B) invoice.payment_succeeded

    -- 8B.1) Siempre upsert para mergear metadata; lookup interno por invoice/subscription
    v_order_id := f_order_headers_upsert(
      v_user_id, v_amount_cents, v_currency, 'paid',
      v_session_id, v_invoice_id, v_subscription_id,
      v_payment_intent, v_customer, v_metadata
    );

    -- 8B.2) Registrar/actualizar pago y ligarlo a la orden
    BEGIN
      SELECT public.f_payments_upsert(v_user_id, v_obj, v_order_id)
        INTO v_payment_id;

      UPDATE public.payments
         SET order_id = v_order_id
       WHERE id = v_payment_id
         AND (order_id IS NULL OR order_id <> v_order_id);
    EXCEPTION WHEN OTHERS THEN
      NULL;
    END;

    -- 8B.3) Renovar / conceder
    v_period_end_txt := v_obj->'lines'->'data'->0->'period'->>'end';
    IF v_period_end_txt ~ '^\d+(\.\d+)?$' THEN
      v_period_end := to_timestamp(v_period_end_txt::double precision);
    ELSIF v_period_end_txt IS NOT NULL AND v_period_end_txt <> '' THEN
      BEGIN
        v_period_end := v_period_end_txt::timestamptz;
      EXCEPTION WHEN OTHERS THEN
        v_period_end := NULL;
      END;
    END IF;

    v_interval_unit  := lower(NULLIF(v_obj->'lines'->'data'->0->'price'->'recurring'->>'interval',''));
    v_interval_count := COALESCE((NULLIF(v_obj->'lines'->'data'->0->'price'->'recurring'->>'interval_count',''))::int, 1);

    v_metadata := v_metadata
                  |jsonb_build_object(
                       'invoice_id',         v_invoice_id,
                       'subscription_id',    v_subscription_id,
                       'recurring_interval', v_interval_unit,
                       'interval_count',     v_interval_count
                     );

    PERFORM f_entitlements_apply(
      v_user_id, v_order_id, v_sku, v_fulfillment_type, v_metadata, v_period_end, 'system:backend'
    );
  END IF;

  -- 10) Marcar procesado
  PERFORM f_webhooks_mark_processed(v_event_id, v_order_id);

  RETURN v_order_id;

EXCEPTION
  WHEN OTHERS THEN
    RAISE;
END;
$function$

CREATE OR REPLACE FUNCTION public.f_debug_orders_parse_payment_from_payload(session_payload jsonb)
 RETURNS TABLE(amount_cents integer, currency text, seen_total integer, seen_amount_paid integer, seen_amount_due integer, seen_subtotal integer, seen_currency text, line0_amount integer, line0_price_currency text)
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
DECLARE
  v_obj jsonb;
BEGIN
  v_obj := session_payload->'data'->'object';

  RETURN QUERY
  SELECT
    f.amount_cents,
    f.currency,
    NULLIF(v_obj->>'total','')::int            AS seen_total,
    NULLIF(v_obj->>'amount_paid','')::int      AS seen_amount_paid,
    NULLIF(v_obj->>'amount_due','')::int       AS seen_amount_due,
    NULLIF(v_obj->>'subtotal','')::int         AS seen_subtotal,
    lower(NULLIF(v_obj->>'currency',''))       AS seen_currency,
    NULLIF(v_obj#>>'{lines,data,0,amount}','')::int AS line0_amount,
    v_obj#>>'{lines,data,0,price,currency}'    AS line0_price_currency
  FROM public.f_orders_parse_payment(v_obj) AS f;
END;
$function$

CREATE OR REPLACE FUNCTION public.f_debug_get_payments_by_order(p_order_id uuid)
 RETURNS TABLE(id uuid, user_id uuid, order_id uuid, total_cents integer, currency text, status text, stripe_invoice_id text, stripe_payment_intent_id text, stripe_subscription_id text, stripe_customer_id text, period_start timestamp with time zone, period_end timestamp with time zone, metadata jsonb, created_at timestamp with time zone, updated_at timestamp with time zone)
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
BEGIN
  PERFORM set_config('row_security','off', true);
  RETURN QUERY
  SELECT
    p.id, p.user_id, p.order_id, p.total_cents, p.currency, p.status,
    p.stripe_invoice_id, p.stripe_payment_intent_id, p.stripe_subscription_id,
    p.stripe_customer_id, p.period_start, p.period_end, p.metadata,
    p.created_at, p.updated_at
  FROM public.payments p
  WHERE p.order_id = p_order_id
     OR p.stripe_invoice_id = (SELECT oh.stripe_invoice_id FROM public.order_headers oh WHERE oh.id = p_order_id);
END;
$function$

CREATE OR REPLACE FUNCTION public.f_debug_get_entitlements_by_order(p_order_id uuid)
 RETURNS TABLE(id uuid, user_id uuid, sku text, fulfillment_type text, source_type entitlement_source_type, source_id text, active boolean, valid_until timestamp with time zone, metadata jsonb, created_at timestamp with time zone, updated_at timestamp with time zone)
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
BEGIN
  PERFORM set_config('row_security','off', true);
  RETURN QUERY
  SELECT
    e.id, e.user_id, e.sku, e.fulfillment_type, e.source_type,
    e.source_id::text, e.active, e.valid_until, e.metadata,
    e.created_at, e.updated_at
  FROM public.entitlements e
  WHERE e.source_type = 'order'::entitlement_source_type
    AND e.source_id::uuid = p_order_id
  ORDER BY e.updated_at DESC NULLS LAST, e.created_at DESC;
END;
$function$

CREATE OR REPLACE FUNCTION public.f_debug_get_order(p_order_id uuid)
 RETURNS TABLE(id uuid, user_id uuid, order_number text, total_cents integer, currency text, status text, stripe_session_id text, stripe_invoice_id text, stripe_subscription_id text, stripe_payment_intent_id text, stripe_customer_id text, metadata jsonb, created_at timestamp with time zone, updated_at timestamp with time zone)
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
BEGIN
  -- Desactiva RLS para esta ejecución (requiere owner con privilegios)
  PERFORM set_config('row_security','off', true);

  RETURN QUERY
  SELECT
    oh.id,
    oh.user_id,
    oh.order_number,
    oh.total_cents,
    oh.currency,
    oh.status,
    oh.stripe_session_id,
    oh.stripe_invoice_id,
    oh.stripe_subscription_id,
    oh.stripe_payment_intent_id,
    oh.stripe_customer_id,
    oh.metadata,
    oh.created_at,
    oh.updated_at
  FROM public.order_headers oh
  WHERE oh.id = p_order_id;
END;
$function$

CREATE OR REPLACE FUNCTION public.f_debug_orders_payment_both(session_payload jsonb)
 RETURNS TABLE(manual_amount_cents integer, manual_currency text, parser_amount_cents integer, parser_currency text, seen_total integer, seen_amount_paid integer, seen_amount_due integer, seen_subtotal integer, seen_currency text, line0_amount integer, line0_amount_total integer, line0_currency text, line0_price_currency text)
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
DECLARE
  v_obj            jsonb;
  v_lines_total    integer := 0;
  li               jsonb;
  v_manual_amount  integer;
  v_manual_currency text;
  v_parser_amount  integer;
  v_parser_currency text;
BEGIN
  -- Extrae el objeto como lo hace f_orch_orders_upsert
  v_obj := session_payload->'data'->'object';

  -- Suma por líneas como último recurso
  FOR li IN
    SELECT elem FROM jsonb_array_elements(COALESCE(v_obj #> '{lines,data}', '[]'::jsonb)) AS t(elem)
  LOOP
    v_lines_total := v_lines_total
      + COALESCE(
          NULLIF(li->>'amount','')::int,
          NULLIF(li->>'amount_total','')::int,
          CASE
            WHEN (li #>> '{pricing,price_details,unit_amount_decimal}') IS NOT NULL
                 AND (li->>'quantity') IS NOT NULL
            THEN ((li #>> '{pricing,price_details,unit_amount_decimal}')::numeric
                  * NULLIF(li->>'quantity','')::int)::int
            ELSE NULL
          END,
          0
        );
  END LOOP;

  -- Manual: mismos fallbacks que el parser actualizado
  v_manual_amount := COALESCE(
    NULLIF(v_obj->>'amount_total','')::int,
    NULLIF(v_obj->>'amount_paid','')::int,
    NULLIF(v_obj->>'total','')::int,
    NULLIF(v_obj->>'amount_due','')::int,
    NULLIF(v_obj->>'subtotal','')::int,
    v_lines_total
  );

  v_manual_currency := lower(trim(NULLIF(v_obj->>'currency','')));
  IF v_manual_currency IS NULL OR v_manual_currency = '' THEN
    v_manual_currency := lower(trim(NULLIF((v_obj #> '{lines,data,0}') ->> 'currency','')));
  END IF;
  IF v_manual_currency IS NULL OR v_manual_currency = '' THEN
    v_manual_currency := lower(trim(NULLIF((v_obj #> '{lines,data,0,price}') ->> 'currency','')));
  END IF;

  -- Llamada al parser, capturando errores
  BEGIN
    SELECT f.amount_cents, f.currency
    INTO v_parser_amount, v_parser_currency
    FROM public.f_orders_parse_payment(v_obj) AS f;
  EXCEPTION
    WHEN OTHERS THEN
      v_parser_amount := NULL;
      v_parser_currency := NULL;
  END;

  -- Devuelve ambas lecturas y lo "visto" por el RPC
  RETURN QUERY
  SELECT
    v_manual_amount                         AS manual_amount_cents,
    v_manual_currency                       AS manual_currency,
    v_parser_amount                         AS parser_amount_cents,
    v_parser_currency                       AS parser_currency,
    NULLIF(v_obj->>'total','')::int         AS seen_total,
    NULLIF(v_obj->>'amount_paid','')::int   AS seen_amount_paid,
    NULLIF(v_obj->>'amount_due','')::int    AS seen_amount_due,
    NULLIF(v_obj->>'subtotal','')::int      AS seen_subtotal,
    lower(NULLIF(v_obj->>'currency',''))    AS seen_currency,
    NULLIF(v_obj#>>'{lines,data,0,amount}','')::int         AS line0_amount,
    NULLIF(v_obj#>>'{lines,data,0,amount_total}','')::int   AS line0_amount_total,
    v_obj#>>'{lines,data,0,currency}'       AS line0_currency,
    v_obj#>>'{lines,data,0,price,currency}' AS line0_price_currency;

END;
$function$

CREATE OR REPLACE FUNCTION public.f_rate_limit_touch_v1(v_input jsonb)
 RETURNS jsonb
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
declare
  _scope        text := coalesce(v_input->>'scope','forms');
  _type         text := v_input->>'type';

  _ip_hash      text := v_input->>'ip_hash';
  _email_hash   text := nullif(v_input->>'email_hash','');

  _b_minutes    int  := coalesce((v_input->'burst'->>'window_minutes')::int, 1);
  _b_ip_thr     int  := coalesce((v_input->'burst'->'thresholds'->>'ip')::int, 3);
  _b_em_thr     int  := coalesce((v_input->'burst'->'thresholds'->>'email')::int, 2);

  _s_minutes    int  := coalesce((v_input->'sustained'->>'window_minutes')::int, 10);
  _s_ip_thr     int  := coalesce((v_input->'sustained'->'thresholds'->>'ip')::int, 8);
  _s_em_thr     int  := coalesce((v_input->'sustained'->'thresholds'->>'email')::int, 3);

  _now          timestamptz := now();
  _burst_start  timestamptz := date_trunc('minute', _now) - make_interval(mins => extract(minute from _now)::int % _b_minutes);
  _sust_start   timestamptz := date_trunc('minute', _now) - make_interval(mins => extract(minute from _now)::int % _s_minutes);

  _ip_burst       int := 0;
  _em_burst       int := 0;
  _ip_sustained   int := 0;
  _em_sustained   int := 0;

  _limited     boolean := false;
  _reason      text := null;
begin
  if _type is null then
    return jsonb_build_object('limited', false, 'reason', null, 'ip_burst',0,'email_burst',0,'ip_sustained',0,'email_sustained',0);
  end if;

  -- Upsert IP burst
  insert into public.rate_limits(scope,type,bucket,key_hash,window_started_at,count,updated_at)
  values(_scope,_type,'burst',_ip_hash,_burst_start,1,_now)
  on conflict(scope,type,bucket,key_hash,window_started_at)
  do update set count = public.rate_limits.count + 1, updated_at = excluded.updated_at
  returning count into _ip_burst;

  -- Upsert IP sustained
  insert into public.rate_limits(scope,type,bucket,key_hash,window_started_at,count,updated_at)
  values(_scope,_type,'sustained',_ip_hash,_sust_start,1,_now)
  on conflict(scope,type,bucket,key_hash,window_started_at)
  do update set count = public.rate_limits.count + 1, updated_at = excluded.updated_at
  returning count into _ip_sustained;

  -- Email puede ser null: solo cuenta si viene
  if _email_hash is not null then
    insert into public.rate_limits(scope,type,bucket,key_hash,window_started_at,count,updated_at)
    values(_scope,_type,'burst',_email_hash,_burst_start,1,_now)
    on conflict(scope,type,bucket,key_hash,window_started_at)
    do update set count = public.rate_limits.count + 1, updated_at = excluded.updated_at
    returning count into _em_burst;

    insert into public.rate_limits(scope,type,bucket,key_hash,window_started_at,count,updated_at)
    values(_scope,_type,'sustained',_email_hash,_sust_start,1,_now)
    on conflict(scope,type,bucket,key_hash,window_started_at)
    do update set count = public.rate_limits.count + 1, updated_at = excluded.updated_at
    returning count into _em_sustained;
  else
    _em_burst := 0;
    _em_sustained := 0;
  end if;

  -- Decisión
  if _ip_burst > _b_ip_thr then
    _limited := true; _reason := 'ip_burst';
  elsif _em_burst > _b_em_thr then
    _limited := true; _reason := 'email_burst';
  elsif _ip_sustained > _s_ip_thr then
    _limited := true; _reason := 'ip_sustained';
  elsif _em_sustained > _s_em_thr then
    _limited := true; _reason := 'email_sustained';
  end if;

  return jsonb_build_object(
    'limited', _limited,
    'reason',  coalesce(_reason,null),
    'ip_burst', _ip_burst,
    'email_burst', _em_burst,
    'ip_sustained', _ip_sustained,
    'email_sustained', _em_sustained
  );
end;
$function$